CEGMON: WHAT CAN IT DO FOR YOUR UK101?

Practical Electronics, Mar 81

CEGMON is to-some extent a "clear up" campaign by Ohio Scientifics, in
which a 2516/2716 EPROM replaces the original SYNMON ROM to give the
system the benefit of a full 2K monitor and all the facilities that this
allows. Ohio's original monitor was all things to all machines, such
that the 2K in your Superboard monitor would have only a small part of
it dedicated to your particular machine, the rest being there to make
the same package compatible with other systems in Ohio's range.  This
philosophy is a hangover from the days of more expensive memory, and the
situation is the same for MONUK101 on the Compukit, which of course, is
the son of Superboard!

Now, for the sake of two or three very simple wiring alterations
to accommodate the 2716's Enable and supply lines, you can plug in the
CEGMON chip and be ready to go; immediately having the following
additional power to your programming elbow:

ASCII KEYBOARD

The polled keyboard is decoded in conventional ASCII format, such that
with Shift-Lock released it is rather more conventional. The two Shift
keys are decoded identically; Carriage Return, Line-Feed, Rubout and
Escape (not UK101) are all accessible regardless of the state of Shifts
or Shift-Lock. Control returns the same value from alphabetical keys
regardless of Shift or Shift-Lock, whereas Shift-Lock does work with
Control for non-alphabet keys, to access otherwise inaccessible
characters. For the same reason, Shift and Shift-Lock pressed together
with alphabetic keys will still produce a range of unrelated characters,
in order to allow Shift-K to -0 to access the up-arrow (and others in
the range 91-95).

A SCREEN HANDLER

Cegmon's screen control system allows a protected area and a scrolling
window. All output to the screen is via a window whose position, height
and width are user-definable, and software controllable. Four
cursor-position commands, a window-clear command, and full screen-clear,
are available, see Table 1. The display starts at the top of the screen,
and printing is very fast until scrolling is necessary.

Table 1. Cursor Controls

CTRL-J		CHR$(10)   cursor down (Line-Feed)
CTRL-K		CHR$(11)   cursor right
CTRL-L		CHR$(12)   cursor home (to top left of window)
CTRL-M		CHR$(13)   cursor left to start of line
                           (Carriage Return)
CTRL-Z		CHR$(26)   clear screen
CTRL-SH1FT-N	CHR$(30)   clear window

Window-clear is called by CTRL-"up-arrow" or CHR$(30), which clears and
homes but does not print the cursor. Total screen clear is implemented
by CTRL-Z, or CHR$(26).

Programming with multiple windows is possible, and parameters of the
current window are held in five memory locations, from 546-550, see
Table 2. SWIDTH needs to be one less than the number of characters to
be printed per line.

Table 2. Store Names and Contents

SWIDTH		column width (-1)
SLTOP		low byte of TOP
SHTOP		high byte of TOP
SLBASE		low byte of BASE
SHBASE		high byte of BASE
LTEXT		555 low byte of text-line start
HTEXT		556 high byte of text-line start

Scrolling and clearing operate from the window TOP and BASE inclusive,
such that, for example, one section of screen may be scrolled relative
to another static part of the screen. A danger, however, is that no
check is made to ensure that TOP and BASE are within the screen memory!
But this does allow any memory-mapped device to be accessed and PRINTed
to by defining a window. Ideal for PRINTing colour values or PRINTing
to an additional display. This does give the expansionist enormous
flexibility.

IN THE MONITOR

Cegmon is not as comprehensive as OSI's Extended Monitor (ExMon), but
it may be co-resident with both BASIC and Assembler, and is immediately
available on switch-on, of course. It would be useful for developing
short m/c routines or for debugging - larger routines being developed
with an Assembler.

On start-up via M, the monitor's prompt > appears - after a clear-screen.
The commands then available are:

/  jump to data mode, leaving current address unchanged
.  "do nothing" - loop back to get address
L  sets load flag - calls for input from the BASIC load vector
   at $FFEB
S  save machine code
M  do memory block move
T  do tabular dump/display of memory contents
Z  set a breakpoint
R  restart from a breakpoint
U  jump to user routine


In the data mode loop the following commands are available:

.  return to address mode
/  re-open current address, to correct a mis-type
G  start execution at the current address
'  enter text entry loop
,  increment current address
LF (Line-Feed) - increment current address, do CR/LF, display
   new Current address and contents on next line
CR (Carriage Return) - as for LF, but do CR only; display by
   overwriting on same line
^  (up-arrow, SHIFT-N) - as for LF, but decrement current
   address

In Command/address mode the following key strokes apply:

/  jump to data mode

   On start-up, the current address is set to zero; thereafter it is
   not changed on a restart.

L  load
   The m/c load flag is set and the system restarts at the beginning
   of the data mode loop. It then expects input via the ACIA, either
   from tape or RS-232 serial interface. Load can run up to 4800
   Baud (1MHz machine).

S  save
   The Syntax is: .Saaaa,bbbb cccc where cccc is the restart address,
   either to the beginning of the routine for auto-start, or back to
   the monitor. Code is saved from aaaa to bbbb. Save waits until
   Return is pressed to give you time to start your recorder. The
   "start" and "go" addresses and hex codes are displayed. It should
   be noted that the CR which separates each byte is directed to the
   ACIA, and as a result, this routine cannot vector a user-defined
   output, i.e. it can only be used through the ACIA for the cassette
   port and RS-232 interface.

M  memory block move
   This Syntax is: .Maaaa,bbbb cccc where aaaa is the start of
   the code to be copied, bbbb is the end, and cccc is the new start
   location.

T  tabular display
   Syntax: .Taaaa,bbbb where the code displayed is aaaa
   bbbb. The memory contents are displayed as a table of eight
   byte blocks.

Z  zero - set breakpoint
   Syntax: .Zaaaa where aaaa is the address at which the breakpoint is
   to be inserted. The original content of the chosen address is stored
   at BRKVAL.

R  restart
   Restart from a breakpoint.

U  jump to user routine
   Causes a jump-indirect to a routine whose start address is held in
   $0233-34. This is useful for calls to regularly - used locations like
   the Assembler restart

In Data Mode: the following keystrokes apply:

.  exit to command/address mode

/  re-open current address
   Used if the value just typed was incorrect.

G  go
   Sets all registers to $00, and starts execution at the current
   address.

'  start text mode
   The text mode expects ASCII text rather than hex digits. Control
   characters such as cursor controls, and graphics characters, can also
   be typed direct into memory. No editing is possible without exiting
   back to the data mode. A second ' exits back to the data mode on the
   same line.

,  increment current address
   Used to space succeeding entries into memory. The contents of the
   missed addresses are left unaltered.

LF line-feed - increment current address, display on next line

CR carriage-return - increment current address, display on current line

^  Up-arrow (SHIFT-N) - decrement current address, display on next line
   Identical to LF, except that the current address is decremented
   rather than incremented.

EDITOR

The Editor works in much the same way as that which we published for
Compukit in the November 1980 issue of PE, except that it is a full page
editor (i.e. the line to be altered need not be listed separately).

The Edit cursor is generated, or eliminated, by CTRL-E, and may be moved
around the screen according to the rules shown in Table 3. CTRL-Q copies
forward to reproduce on the Edit line at the foot of the screen, and of
course, extra characters can be interjected via normal keystrokes, whilst
characters can also be "dropped" through the use of CTRL-D.

An editor such as this is the basic next step for anyone wishing to
upgrade their system firmware from the standard of the UK101.

Table 3. Edit Cursor Controls

CTRL-E   Generate or remove edit cursor
CTRL-D   Move forward (does not copy)
CTRL-Q   Copy forward (copies character, & over which it passes)
CTRL-A   Move backwards
CTRL-F   Move down
CTRL-S   Move up

THE MANUAL

The documentation accompanying CEGMON is well presented and generous in
its information, and although most references are intended for the OSI
camp, there is very little which does not also apply to the UK101.

Editing, error handling and break-point handling are explained, and much
of the philosophy behind CEGMON is revealed too, which is helpful.

A Trace routine, Graph Plotter and other useful software is included in
the manual to help the user to make the best use of the facilities
available. Perhaps most importantly, a listing of routine entry points,
data storage locations, and what each of these does is found at the end
of the booklet.

Some of the niggling points of the UK101 remain after fitting CEGMON,
like the unnecessary error message on that first attempt at a Command
Mode instruction. For instance after a CTRL-Z (clear screen), the
machine will come back with an error message the first time you try to
do anything. However, this is familiar behaviour, and the exciting
additional facilities which CEGMON provides would, for many users, make
it worth the added investment of £29.50 + VAT.

NOTE

The price of these monitors is, In our view, rather high in comparison
to the hardware used (2716's are available for under £5.00 retail).
However, we understand that another UK101 monitor is being developed
by an independent source and this one will sell at less then £20.00.

We hope to review it as soon as it is available.

